{
  "name": "Generate Reel",
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -496,
        -192
      ],
      "id": "1ad51777-23c9-4d97-a333-171626e1b7f1",
      "name": "When clicking ‘Execute workflow’"
    },
    {
      "parameters": {
        "authentication": "privateKey",
        "command": "zsh -lc 'source ~/.zshrc; whisper video.mp4 --model medium --output_format json --word_timestamps True --verbose False'",
        "cwd": "/tmp/videos"
      },
      "type": "n8n-nodes-base.ssh",
      "typeVersion": 1,
      "position": [
        -48,
        -192
      ],
      "id": "06f03584-337b-49ee-aed6-6fc2a770af5b",
      "name": "Generate Transcript",
      "credentials": {
        "sshPrivateKey": {
          "id": "IkkggOWpFByQpMbn",
          "name": "SSH Password account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "fileSelector": "/home/node/.n8n-files/video.json",
        "options": {}
      },
      "type": "n8n-nodes-base.readWriteFile",
      "typeVersion": 1,
      "position": [
        176,
        -192
      ],
      "id": "f79ee27d-5952-439f-a521-225e24d5daa1",
      "name": "Get Transcript"
    },
    {
      "parameters": {
        "authentication": "privateKey",
        "command": "zsh -lc 'source ~/.zshrc; compress video.mov'",
        "cwd": "/tmp/videos"
      },
      "type": "n8n-nodes-base.ssh",
      "typeVersion": 1,
      "position": [
        -272,
        -192
      ],
      "id": "c4f2e275-474f-445f-b4ec-26debddaebfb",
      "name": "Compress Video",
      "credentials": {
        "sshPrivateKey": {
          "id": "IkkggOWpFByQpMbn",
          "name": "SSH Password account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "operation": "write",
        "fileName": "/home/node/.n8n-files/transcript.ass",
        "options": {}
      },
      "type": "n8n-nodes-base.readWriteFile",
      "typeVersion": 1,
      "position": [
        1072,
        -192
      ],
      "id": "59e3eeba-97e1-4428-b150-55daf18a8bfb",
      "name": "Read/Write Files from Disk"
    },
    {
      "parameters": {
        "operation": "toText",
        "sourceProperty": "processed.exportFormats.ass",
        "options": {}
      },
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [
        848,
        -192
      ],
      "id": "7815fd62-6e18-4084-bb5c-0eb7005d621b",
      "name": "Convert to File"
    },
    {
      "parameters": {
        "authentication": "privateKey",
        "command": "=zsh -lc 'source ~/.zshrc; rm -rf reel.mp4; ffmpeg -i merged.mp4 \\\n-vf \"subtitles=transcript.ass\" \\\n-c:a copy \\\nreel.mp4'",
        "cwd": "/tmp/videos"
      },
      "type": "n8n-nodes-base.ssh",
      "typeVersion": 1,
      "position": [
        1968,
        -192
      ],
      "id": "3b07a13b-9566-40e7-b154-67ee509dd33d",
      "name": "Burn Subtitles",
      "credentials": {
        "sshPrivateKey": {
          "id": "IkkggOWpFByQpMbn",
          "name": "SSH Password account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// n8n Code Node - Whisper Transcription Data Processor\n// Processes Whisper API transcription output with segments and word-level timing\n// Compatible with n8n workflow automation\n\n// Get input data from n8n\nconst items = $input.all();\n\nfunction processTranscriptionData(data) {\n  // Extract main text\n  const fullText = data.text || '';\n\n  // Process segments\n  const segments = (data.segments || []).map((segment, index) => {\n    return {\n      id: segment.id || index,\n      startTime: segment.start || 0,\n      endTime: segment.end || 0,\n      duration: (segment.end || 0) - (segment.start || 0),\n      text: segment.text || '',\n\n      // Include word-level data for karaoke subtitles (preserve original structure)\n      words: segment.words || [],\n\n      // Confidence metrics\n      avgLogProb: segment.avg_logprob || 0,\n      noSpeechProb: segment.no_speech_prob || 0,\n      temperature: segment.temperature || 0,\n      compressionRatio: segment.compression_ratio || 0,\n\n      // Word count and timing analysis\n      wordCount: (segment.words || []).length,\n      wordsPerSecond: segment.words ?\n        segment.words.length / ((segment.end || 0) - (segment.start || 0) || 1) : 0,\n\n      // Extract high-confidence words (probability > 0.8)\n      highConfidenceWords: (segment.words || []).filter(word =>\n        (word.probability || 0) > 0.8\n      ).map(word => word.word).join(' '),\n\n      // Extract low-confidence words (probability < 0.5) for review\n      lowConfidenceWords: (segment.words || []).filter(word =>\n        (word.probability || 0) < 0.5\n      ).map(word => ({\n        word: word.word,\n        probability: word.probability,\n        start: word.start,\n        end: word.end\n      }))\n    };\n  });\n\n  // Generate summary statistics\n  const stats = {\n    totalDuration: segments.length > 0 ?\n      Math.max(...segments.map(s => s.endTime)) : 0,\n    totalSegments: segments.length,\n    totalWords: segments.reduce((sum, seg) => sum + seg.wordCount, 0),\n    averageConfidence: segments.length > 0 ?\n      segments.reduce((sum, seg) => sum + Math.abs(seg.avgLogProb), 0) / segments.length : 0,\n    languageDetected: data.language || 'unknown',\n\n    // Identify segments with potential issues\n    lowConfidenceSegments: segments.filter(seg => seg.avgLogProb < -0.5).length,\n    highNoSpeechSegments: segments.filter(seg => seg.noSpeechProb > 0.1).length\n  };\n\n  // Extract timestamps for easy navigation\n  const timeMarkers = segments.map(segment => ({\n    segmentId: segment.id,\n    timestamp: segment.startTime,\n    text: segment.text.substring(0, 50) + (segment.text.length > 50 ? '...' : ''),\n    confidence: Math.abs(segment.avgLogProb)\n  }));\n\n  // Generate cleaned transcript (remove filler words, fix spacing)\n  const cleanedText = fullText\n    .replace(/\\s+/g, ' ')  // Multiple spaces to single\n    .replace(/\\b(um|uh|er|ah)\\b/gi, '')  // Remove common filler words\n    .replace(/\\s+/g, ' ')  // Clean up spaces after filler removal\n    .trim();\n\n  // Split into paragraphs based on longer pauses (gaps > 2 seconds)\n  const paragraphs = [];\n  let currentParagraph = [];\n\n  for (let i = 0; i < segments.length; i++) {\n    const currentSegment = segments[i];\n    const nextSegment = segments[i + 1];\n\n    currentParagraph.push(currentSegment.text.trim());\n\n    // End paragraph if there's a significant pause or it's the last segment\n    if (!nextSegment || (nextSegment.startTime - currentSegment.endTime) > 2) {\n      if (currentParagraph.length > 0) {\n        paragraphs.push(currentParagraph.join(' ').trim());\n        currentParagraph = [];\n      }\n    }\n  }\n\n  return {\n    // Original data\n    originalText: fullText,\n    language: data.language,\n\n    // Processed data\n    cleanedText,\n    paragraphs,\n    segments,\n\n    // Analytics\n    statistics: stats,\n    timeMarkers,\n\n    // For further processing\n    exportFormats: {\n      srt: generateSRT(segments),\n      vtt: generateVTT(segments),\n      ass: generateASS(data.segments || []),\n      plainText: cleanedText,\n      wordTimings: extractWordTimings(data.segments || [])\n    }\n  };\n}\n\n// Generate SRT subtitle format\nfunction generateSRT(segments) {\n  return segments.map((segment, index) => {\n    const startTime = formatTime(segment.startTime);\n    const endTime = formatTime(segment.endTime);\n    return `${index + 1}\\n${startTime} --> ${endTime}\\n${segment.text.trim()}\\n`;\n  }).join('\\n');\n}\n\n// Generate WebVTT subtitle format\nfunction generateVTT(segments) {\n  const vttHeader = 'WEBVTT\\n\\n';\n  const vttContent = segments.map((segment, index) => {\n    const startTime = formatTime(segment.startTime, true);\n    const endTime = formatTime(segment.endTime, true);\n    return `${startTime} --> ${endTime}\\n${segment.text.trim()}\\n`;\n  }).join('\\n');\n  return vttHeader + vttContent;\n}\n\n// Generate ASS subtitle format with karaoke-style word-by-word timing\nfunction generateASS(segments) {\n  const assHeader = `[Script Info]\nTitle: Karaoke Subtitles\nScriptType: v4.00+\nWrapStyle: 0\nScaledBorderAndShadow: yes\nYCbCr Matrix: TV.601\nPlayResX: 1920\nPlayResY: 1080\n\n[V4+ Styles]\nFormat: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\nStyle: Default,Arial,84,&H00FFFFFF,&H000000FF,&H00000000,&H80000000,1,0,0,0,100,100,0,0,1,4,4,5,50,50,50,1\nStyle: Karaoke,Arial,84,&H0000FFFF,&H000000FF,&H00000000,&H80000000,1,0,0,0,100,100,0,0,1,4,4,5,50,50,50,1\n\n[Events]\nFormat: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n`;\n\n  const assEvents = [];\n\n  // Ensure we have segments to process\n  if (!segments || segments.length === 0) {\n    return assHeader + 'Dialogue: 0,0:00:00.00,0:00:01.00,Karaoke,,0,0,0,,No data available\\n';\n  }\n\n  segments.forEach(segment => {\n    if (segment.words && segment.words.length > 0) {\n      // Create karaoke-style word-by-word events using word-level timing\n      segment.words.forEach(word => {\n        const startTime = formatASSTime(word.start || segment.start || 0);\n        const endTime = formatASSTime(word.end || segment.end || 0);\n        const cleanWord = (word.word || '').trim().replace(/\\n/g, '\\\\N');\n\n        if (cleanWord) {\n          assEvents.push(`Dialogue: 0,${startTime},${endTime},Karaoke,,0,0,0,,${cleanWord}`);\n        }\n      });\n    } else if (segment.text) {\n      // Fallback: split text by words if no word-level timing available\n      const words = segment.text.trim().split(/\\s+/);\n      const segmentDuration = (segment.end || 0) - (segment.start || 0);\n      const timePerWord = segmentDuration > 0 ? segmentDuration / words.length : 1;\n\n      words.forEach((word, index) => {\n        const wordStart = (segment.start || 0) + (index * timePerWord);\n        const wordEnd = (segment.start || 0) + ((index + 1) * timePerWord);\n        const startTime = formatASSTime(wordStart);\n        const endTime = formatASSTime(wordEnd);\n        const cleanWord = word.replace(/\\n/g, '\\\\N');\n\n        if (cleanWord) {\n          assEvents.push(`Dialogue: 0,${startTime},${endTime},Karaoke,,0,0,0,,${cleanWord}`);\n        }\n      });\n    }\n  });\n\n  // Ensure we have at least some content\n  if (assEvents.length === 0) {\n    assEvents.push('Dialogue: 0,0:00:00.00,0:00:01.00,Karaoke,,0,0,0,,Processing error - no dialogue generated');\n  }\n\n  return assHeader + assEvents.join('\\n');\n}\n\n// Format time for ASS subtitles (H:MM:SS.cc)\nfunction formatASSTime(seconds) {\n  const hours = Math.floor(seconds / 3600);\n  const minutes = Math.floor((seconds % 3600) / 60);\n  const secs = Math.floor(seconds % 60);\n  const centiseconds = Math.floor((seconds % 1) * 100);\n\n  return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${centiseconds.toString().padStart(2, '0')}`;\n}\n\n// Format time for subtitles (HH:MM:SS,mmm for SRT, HH:MM:SS.mmm for VTT)\nfunction formatTime(seconds, isVTT = false) {\n  const hours = Math.floor(seconds / 3600);\n  const minutes = Math.floor((seconds % 3600) / 60);\n  const secs = Math.floor(seconds % 60);\n  const ms = Math.floor((seconds % 1) * 1000);\n\n  const separator = isVTT ? '.' : ',';\n  return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}${separator}${ms.toString().padStart(3, '0')}`;\n}\n\n// Extract word-level timings\nfunction extractWordTimings(segments) {\n  const wordTimings = [];\n\n  segments.forEach(segment => {\n    if (segment.words) {\n      segment.words.forEach(word => {\n        wordTimings.push({\n          word: word.word?.trim(),\n          start: word.start,\n          end: word.end,\n          duration: (word.end || 0) - (word.start || 0),\n          probability: word.probability,\n          segmentId: segment.id\n        });\n      });\n    }\n  });\n\n  return wordTimings;\n}\n\n// Process all input items for n8n\nconst processedItems = items.map(item => {\n  try {\n    // Handle different input structures\n    let transcriptionData;\n\n    // Check if data is in binary format first\n    if (item.binary && item.binary.data) {\n      // If it's binary data, try to parse it\n      try {\n        const binaryData = item.binary.data;\n        transcriptionData = JSON.parse(binaryData);\n      } catch (e) {\n        console.log('Failed to parse binary data:', e);\n        transcriptionData = item.json || item;\n      }\n    } else if (item.json) {\n      // Extract data directly from n8n json structure\n      transcriptionData = item.json.data || item.json;\n    } else {\n      transcriptionData = item;\n    }\n\n    // Handle array structure from file input (like video.json)\n    if (Array.isArray(transcriptionData) && transcriptionData.length > 0) {\n      // Extract the data object from the first array element\n      transcriptionData = transcriptionData[0].data || transcriptionData[0];\n    }\n\n    // Process the transcription data\n    const processed = processTranscriptionData(transcriptionData);\n\n    return {\n      json: {\n        success: true,\n        processed: processed,\n        metadata: {\n          processedAt: new Date().toISOString(),\n          processingTime: Date.now() - (new Date().getTime()),\n          inputType: 'whisper-transcription'\n        }\n      }\n    };\n\n  } catch (error) {\n    return {\n      json: {\n        success: false,\n        error: error.message,\n        originalData: item,\n        metadata: {\n          processedAt: new Date().toISOString(),\n          inputType: 'error'\n        }\n      }\n    };\n  }\n});\n\n// Return processed items for n8n\nreturn processedItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        624,
        -192
      ],
      "id": "0155f51e-42a9-4e7d-8ef4-4bb55179c05a",
      "name": "JSON to ASS Convertor"
    },
    {
      "parameters": {
        "authentication": "privateKey",
        "command": "=zsh -lc 'source ~/.zshrc; rm -rf cut1.mp4; ffmpeg -i video.mp4 -vf \"crop=588.7294117647058:523.3150326797385:60.51764705882351:631.2239079233881\" -c:v libx264 -crf 18 -preset medium -c:a copy cut1.mp4'",
        "cwd": "/tmp/videos"
      },
      "type": "n8n-nodes-base.ssh",
      "typeVersion": 1,
      "position": [
        1296,
        -192
      ],
      "id": "7a9144e6-ff02-4a84-ace8-bcb2f6362a4b",
      "name": "Cut 1",
      "credentials": {
        "sshPrivateKey": {
          "id": "IkkggOWpFByQpMbn",
          "name": "SSH Password account"
        }
      }
    },
    {
      "parameters": {
        "authentication": "privateKey",
        "command": "=zsh -lc 'source ~/.zshrc; rm -rf cut2.mp4; ffmpeg -i video.mp4 -vf \"crop=588.7294117647058:523.3150326797385:1970.6352941176467:570.1172999155665\" -c:v libx264 -crf 18 -preset medium -c:a copy cut2.mp4'",
        "cwd": "/tmp/videos"
      },
      "type": "n8n-nodes-base.ssh",
      "typeVersion": 1,
      "position": [
        1520,
        -192
      ],
      "id": "df61eb3c-8db1-4d5c-835e-308e05f6d563",
      "name": "Cut 2",
      "credentials": {
        "sshPrivateKey": {
          "id": "IkkggOWpFByQpMbn",
          "name": "SSH Password account"
        }
      }
    },
    {
      "parameters": {
        "authentication": "privateKey",
        "command": "zsh -lc 'source ~/.zshrc; rm -rf merged.mp4; ffmpeg -i cut1.mp4 -i cut2.mp4 \\\n-filter_complex \"[0:v][1:v]vstack=inputs=2[v]\" \\\n-map \"[v]\" -map \"0:a?\" \\\nmerged.mp4'",
        "cwd": "/tmp/videos"
      },
      "type": "n8n-nodes-base.ssh",
      "typeVersion": 1,
      "position": [
        1744,
        -192
      ],
      "id": "b8cc94c7-293c-4bd0-984e-17c2f22fbffa",
      "name": "Merge Cut 1 & 2",
      "credentials": {
        "sshPrivateKey": {
          "id": "IkkggOWpFByQpMbn",
          "name": "SSH Password account"
        }
      }
    },
    {
      "parameters": {
        "operation": "fromJson",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1.1,
      "position": [
        400,
        -192
      ],
      "id": "2c9f7f01-7dc1-49cc-aab1-e25fdadd64b4",
      "name": "Extract from File"
    }
  ],
  "pinData": {},
  "connections": {
    "When clicking ‘Execute workflow’": {
      "main": [
        [
          {
            "node": "Compress Video",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Transcript": {
      "main": [
        [
          {
            "node": "Get Transcript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Transcript": {
      "main": [
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compress Video": {
      "main": [
        [
          {
            "node": "Generate Transcript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read/Write Files from Disk": {
      "main": [
        [
          {
            "node": "Cut 1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to File": {
      "main": [
        [
          {
            "node": "Read/Write Files from Disk",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "JSON to ASS Convertor": {
      "main": [
        [
          {
            "node": "Convert to File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cut 1": {
      "main": [
        [
          {
            "node": "Cut 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cut 2": {
      "main": [
        [
          {
            "node": "Merge Cut 1 & 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Cut 1 & 2": {
      "main": [
        [
          {
            "node": "Burn Subtitles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "JSON to ASS Convertor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "f0fd1449-62f1-4b2b-890d-fc07637c5723",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "1ef27c04422232ed4131fcf36b4f5d8f8efff3c9b6a102a2529f396587e22c55"
  },
  "id": "bZQix2X1XRIrSASF",
  "tags": []
}