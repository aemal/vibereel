<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Cut Rectangle Tool - Vibe Reel</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --bg-dark: #0a0e14;
            --bg-card: #151921;
            --bg-input: #1a1f2b;
            --accent-cyan: #00d9ff;
            --accent-green: #00ff9f;
            --accent-yellow: #ffd500;
            --accent-red: #ff3366;
            --text-primary: #e6e9ef;
            --text-secondary: #8b92a3;
            --border: #2a2f3a;
        }
        
        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 40px 20px;
            display: flex;
            gap: 30px;
            min-height: 100vh;
        }

        .main-content {
            flex: 1;
            min-width: 0;
        }

        .right-sidebar {
            width: 280px;
            flex-shrink: 0;
        }
        .header { text-align: center; margin-bottom: 50px; }
        .logo { font-size: 14px; letter-spacing: 3px; color: var(--accent-cyan); margin-bottom: 10px; font-weight: 700; text-transform: uppercase; }
        h1 { font-size: 48px; font-weight: 700; margin-bottom: 15px; background: linear-gradient(135deg, var(--accent-cyan), var(--accent-green)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .subtitle { color: var(--text-secondary); font-size: 14px; }
        
        .upload-section {
            background: var(--bg-card);
            border: 2px dashed var(--border);
            border-radius: 12px;
            padding: 60px 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .upload-section:hover { border-color: var(--accent-cyan); }
        .upload-section.drag-over {
            border-color: var(--accent-green);
            background: rgba(0, 255, 159, 0.1);
            transform: scale(1.02);
        }
        .upload-icon { font-size: 64px; margin-bottom: 20px; }
        .upload-text { font-size: 16px; margin-bottom: 10px; font-weight: 600; }
        
        .controls { display: flex; gap: 15px; margin: 30px 0; align-items: center; flex-wrap: wrap; }
        .control-group { flex: 1; min-width: 200px; }
        .control-label { font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase; }
        .time-input { width: 100%; padding: 12px 15px; background: var(--bg-input); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-family: 'JetBrains Mono', monospace; font-size: 14px; }
        
        .detect-btn { padding: 14px 40px; background: linear-gradient(135deg, var(--accent-cyan), var(--accent-green)); border: none; border-radius: 8px; color: var(--bg-dark); font-family: 'JetBrains Mono', monospace; font-size: 14px; font-weight: 700; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease; }
        .detect-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .detect-btn.active { background: var(--accent-yellow); color: var(--bg-dark); transform: scale(1.05); }
        .detect-btn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0, 217, 255, 0.3); }
        
        .canvas-wrapper {
            position: relative;
            margin: 20px 0;
            border-radius: 8px;
            overflow: hidden;
            background: var(--bg-card);
        }
        
        .video-canvas { 
            width: 100%; 
            display: block;
            cursor: crosshair;
        }
        
        .help-text {
            text-align: center;
            color: var(--accent-green);
            font-size: 13px;
            margin: 10px 0;
            padding: 10px;
            background: rgba(0, 255, 159, 0.1);
            border-radius: 8px;
        }
        
        .sync-badge {
            display: inline-block;
            padding: 4px 12px;
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid var(--accent-yellow);
            border-radius: 20px;
            font-size: 11px;
            color: var(--accent-yellow);
            margin-left: 10px;
        }
        
        .results-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-top: 30px; }
        .participant-card { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 20px; }
        .participant-id { font-size: 18px; font-weight: 700; color: var(--accent-cyan); margin-bottom: 15px; }
        .coord-value { font-size: 14px; color: var(--accent-green); margin: 8px 0; }
        
        .ffmpeg-command { background: var(--bg-input); border-radius: 8px; padding: 15px; margin-top: 15px; position: relative; }
        .ffmpeg-code { font-size: 11px; color: var(--accent-yellow); word-break: break-all; padding-right: 60px; line-height: 1.6; }
        .copy-btn { position: absolute; top: 15px; right: 15px; padding: 6px 12px; background: var(--accent-cyan); color: var(--bg-dark); border: none; border-radius: 4px; cursor: pointer; font-size: 11px; }
        
        .loading { text-align: center; padding: 40px; color: var(--text-secondary); }
        .spinner { width: 40px; height: 40px; margin: 0 auto 20px; border: 3px solid var(--border); border-top-color: var(--accent-cyan); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        input[type="file"] { display: none; }
        
        .info-box {
            background: rgba(0, 217, 255, 0.1);
            border: 1px solid rgba(0, 217, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            font-size: 13px;
        }

        .subtitle-preview {
            position: sticky;
            top: 20px;
            width: 200px;
            height: 356px; /* 200 * (16/9) = 355.56 ‚âà 356 for 9:16 aspect ratio */
            background: #000;
            border: 2px solid var(--accent-cyan);
            border-radius: 12px;
            overflow: hidden;
            margin: 0 auto;
        }

        .sidebar-section {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .sidebar-title {
            font-size: 14px;
            color: var(--accent-cyan);
            font-weight: 700;
            margin-bottom: 15px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .subtitle-placeholder {
            position: absolute;
            left: 10px;
            right: 10px;
            height: 40px;
            background: rgba(0, 217, 255, 0.8);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: ns-resize;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: 700;
            color: var(--bg-dark);
            user-select: none;
            transition: background 0.2s ease;
        }

        .subtitle-placeholder:hover {
            background: rgba(0, 217, 255, 1);
        }

        .subtitle-placeholder.dragging {
            background: var(--accent-green);
        }

        .subtitle-preview-label {
            position: absolute;
            top: -30px;
            left: 0;
            font-size: 12px;
            color: var(--accent-cyan);
            font-weight: 600;
        }

        @media (max-width: 1024px) {
            .container {
                flex-direction: column;
                gap: 20px;
            }

            .right-sidebar {
                width: 100%;
                order: -1;
            }

            .subtitle-preview {
                position: relative;
                top: auto;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;
        const COLORS = ['#00d9ff', '#00ff9f'];

        function App() {
            const [video, setVideo] = useState(null);
            const [videoUrl, setVideoUrl] = useState(null);
            const [boxes, setBoxes] = useState([]);
            const [cutMode, setCutMode] = useState(2); // 1, 2, or 3 cuts
            const [seekTime, setSeekTime] = useState(10);
            const [dragging, setDragging] = useState(null);
            const [videoFrame, setVideoFrame] = useState(null);
            const [dragOver, setDragOver] = useState(false);
            const [subtitlePosition, setSubtitlePosition] = useState(700); // Vertical position in pixels from bottom for ASS subtitles
            const [subtitleDragging, setSubtitleDragging] = useState(false);
            
            const fileInputRef = useRef(null);
            const videoRef = useRef(null);
            const canvasRef = useRef(null);

            useEffect(() => {
                // Prevent default browser drag and drop behavior
                const handleGlobalDragOver = (e) => e.preventDefault();
                const handleGlobalDrop = (e) => e.preventDefault();

                document.addEventListener('dragover', handleGlobalDragOver);
                document.addEventListener('drop', handleGlobalDrop);

                return () => {
                    document.removeEventListener('dragover', handleGlobalDragOver);
                    document.removeEventListener('drop', handleGlobalDrop);
                };
            }, []);

            useEffect(() => {
                if (boxes.length > 0 && videoFrame) {
                    redrawCanvas();
                }
            }, [boxes, videoFrame]);

            useEffect(() => {
                // Reset boxes when cut mode changes
                setBoxes([]);
            }, [cutMode]);


            const handleFileSelect = (file) => {
                if (file && file.type.startsWith('video/')) {
                    setVideo(file);
                    setVideoUrl(URL.createObjectURL(file));
                    setBoxes([]);
                    // Load the first frame
                    setTimeout(() => loadVideoFrame(), 500);
                }
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setDragOver(true);
            };

            const handleDragLeave = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setDragOver(false);
            };

            const handleDrop = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setDragOver(false);

                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (file.type.startsWith('video/')) {
                        handleFileSelect(file);
                    } else {
                        alert('Please upload a video file');
                    }
                }
            };

            const loadVideoFrame = async () => {
                if (!videoRef.current || !canvasRef.current) return;

                const videoEl = videoRef.current;
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');

                await new Promise((resolve) => {
                    if (videoEl.readyState >= 1) resolve();
                    else videoEl.onloadedmetadata = resolve;
                });

                const width = videoEl.videoWidth;
                const height = videoEl.videoHeight;
                canvas.width = width;
                canvas.height = height;

                videoEl.currentTime = Math.min(seekTime, videoEl.duration - 1);
                await new Promise((resolve) => { videoEl.onseeked = resolve; });
                await new Promise(resolve => setTimeout(resolve, 200));

                ctx.drawImage(videoEl, 0, 0, width, height);

                // Store frame for redrawing
                setVideoFrame(ctx.getImageData(0, 0, width, height));
            };

            const addRectangle = () => {
                if (!canvasRef.current) return;

                const canvas = canvasRef.current;
                const width = canvas.width;
                const height = canvas.height;

                let newBox;

                if (cutMode === 1) {
                    // Single cut - full vertical reel (1080x1920)
                    if (boxes.length >= 1) return; // Only allow one rectangle

                    const aspectRatio = 1080 / 1920;
                    let boxWidth, boxHeight;

                    // Fit 1080x1920 ratio within canvas
                    const maxWidthFromHeight = height * aspectRatio;
                    const maxHeightFromWidth = width / aspectRatio;

                    if (maxWidthFromHeight <= width) {
                        boxHeight = height * 0.8; // 80% of canvas height
                        boxWidth = boxHeight * aspectRatio;
                    } else {
                        boxWidth = width * 0.8; // 80% of canvas width
                        boxHeight = boxWidth / aspectRatio;
                    }

                    newBox = {
                        id: 1,
                        x: (width - boxWidth) / 2,
                        y: (height - boxHeight) / 2,
                        width: Math.floor(boxWidth),
                        height: Math.floor(boxHeight),
                        color: COLORS[0]
                    };
                } else if (cutMode === 2) {
                    // Two cuts - half reels (1080x960 each)
                    if (boxes.length >= 2) return; // Only allow two rectangles

                    const aspectRatio = 1080 / 960;
                    let boxWidth, boxHeight;

                    // Fit 1080x960 ratio within canvas
                    const maxWidthFromHeight = (height / 2) * aspectRatio;
                    const maxHeightFromWidth = width / aspectRatio;

                    if (maxWidthFromHeight <= width) {
                        boxHeight = (height / 2) * 0.8; // 80% of half canvas height
                        boxWidth = boxHeight * aspectRatio;
                    } else {
                        boxWidth = width * 0.8; // 80% of canvas width
                        boxHeight = boxWidth / aspectRatio;
                    }

                    const yOffset = boxes.length === 0 ? height * 0.1 : height * 0.6;

                    newBox = {
                        id: boxes.length + 1,
                        x: (width - boxWidth) / 2,
                        y: yOffset,
                        width: Math.floor(boxWidth),
                        height: Math.floor(boxHeight),
                        color: COLORS[boxes.length % COLORS.length]
                    };
                } else {
                    // Three cuts - 2 squares + 1 rectangle (total height: 1920)
                    if (boxes.length >= 3) return; // Only allow three shapes

                    if (boxes.length < 2) {
                        // Add squares first (1:1 aspect ratio)
                        const squareSize = Math.min(width, height) * 0.25; // Start with 25% of smaller dimension

                        const xOffset = boxes.length === 0 ? width * 0.2 : width * 0.6;
                        const yOffset = height * 0.15;

                        newBox = {
                            id: boxes.length + 1,
                            x: xOffset,
                            y: yOffset,
                            width: Math.floor(squareSize),
                            height: Math.floor(squareSize),
                            color: COLORS[boxes.length % COLORS.length],
                            type: 'square'
                        };
                    } else {
                        // Add rectangle (calculate height based on squares)
                        const square1 = boxes[0];
                        const square2 = boxes[1];
                        const averageSquareHeight = (square1.height + square2.height) / 2;

                        // Rectangle height = 1920 - (2 * square height)
                        const rectangleHeight = Math.floor(1920 - (2 * averageSquareHeight));
                        const rectangleWidth = square1.width + square2.width; // Width equals sum of both squares

                        newBox = {
                            id: 3,
                            x: (width - rectangleWidth) / 2,
                            y: height * 0.6,
                            width: rectangleWidth,
                            height: rectangleHeight,
                            color: COLORS[2],
                            type: 'rectangle'
                        };
                    }
                }

                setBoxes([...boxes, newBox]);
            };

            const removeRectangle = () => {
                if (boxes.length > 0) {
                    setBoxes(boxes.slice(0, -1));
                }
            };

            const clearAllRectangles = () => {
                setBoxes([]);
            };

            const redrawCanvas = () => {
                const canvas = canvasRef.current;
                if (!canvas || !videoFrame) return;
                
                const ctx = canvas.getContext('2d');
                
                // Redraw original frame
                ctx.putImageData(videoFrame, 0, 0);
                
                // Draw boxes
                boxes.forEach(box => {
                    // Box
                    ctx.strokeStyle = box.color;
                    ctx.lineWidth = 4;
                    ctx.strokeRect(box.x, box.y, box.width, box.height);
                    
                    // Label
                    ctx.fillStyle = box.color;
                    ctx.font = 'bold 24px JetBrains Mono';
                    const label = box.type === 'square' ? `Square ${box.id}` : box.type === 'rectangle' ? 'Rectangle' : `Cut ${box.id}`;
                    ctx.fillText(label, box.x + 10, box.y + 35);
                    
                    // Size indicator
                    ctx.font = '16px JetBrains Mono';
                    ctx.fillText(`${box.width}√ó${box.height}`, box.x + 10, box.y + box.height - 10);
                    
                    // Resize handles (corners)
                    const handleSize = 12;
                    ctx.fillStyle = box.color;
                    
                    // Top-left
                    ctx.fillRect(box.x - handleSize/2, box.y - handleSize/2, handleSize, handleSize);
                    // Top-right
                    ctx.fillRect(box.x + box.width - handleSize/2, box.y - handleSize/2, handleSize, handleSize);
                    // Bottom-left
                    ctx.fillRect(box.x - handleSize/2, box.y + box.height - handleSize/2, handleSize, handleSize);
                    // Bottom-right
                    ctx.fillRect(box.x + box.width - handleSize/2, box.y + box.height - handleSize/2, handleSize, handleSize);
                });
            };

            const syncBoxSize = (changedIndex, newWidth) => {
                const newBoxes = [...boxes];
                let aspectRatio;

                if (cutMode === 1) {
                    aspectRatio = 1080 / 1920; // 1080:1920 ratio for full vertical reel
                    const newHeight = newWidth / aspectRatio;

                    // Update all boxes to same size
                    newBoxes.forEach((box, index) => {
                        box.width = newWidth;
                        box.height = newHeight;
                    });
                } else if (cutMode === 2) {
                    aspectRatio = 1080 / 960; // 1080:960 ratio for half reels
                    const newHeight = newWidth / aspectRatio;

                    // Update all boxes to same size
                    newBoxes.forEach((box, index) => {
                        box.width = newWidth;
                        box.height = newHeight;
                    });
                } else if (cutMode === 3) {
                    // For 3-cut mode: squares maintain 1:1 ratio, rectangle adjusts to fill remaining height
                    const changedBox = newBoxes[changedIndex];

                    if (changedBox.type === 'square') {
                        // If changing a square, keep 1:1 ratio and sync both squares
                        const newSquareSize = newWidth;

                        // Update both squares
                        newBoxes.forEach((box, index) => {
                            if (box.type === 'square') {
                                box.width = newSquareSize;
                                box.height = newSquareSize;
                            }
                        });

                        // Update rectangle to fit remaining height
                        const rectangleBox = newBoxes.find(box => box.type === 'rectangle');
                        if (rectangleBox) {
                            const rectangleHeight = Math.floor(1920 - (2 * newSquareSize));
                            const rectangleWidth = newSquareSize + newSquareSize; // Width equals sum of both squares (both same size)
                            rectangleBox.width = rectangleWidth;
                            rectangleBox.height = rectangleHeight;
                        }
                    } else if (changedBox.type === 'rectangle') {
                        // For rectangle, width changes proportionally with squares
                        // Height changes adjust squares accordingly
                        const newRectHeight = changedBox.height;

                        // Calculate new square size to fit remaining height
                        const remainingHeight = 1920 - newRectHeight;
                        const newSquareSize = Math.floor(remainingHeight / 2);
                        const rectangleWidth = newSquareSize + newSquareSize; // Width equals sum of both squares

                        // Update rectangle width and both squares
                        changedBox.width = rectangleWidth;
                        newBoxes.forEach((box, index) => {
                            if (box.type === 'square') {
                                box.width = newSquareSize;
                                box.height = newSquareSize;
                            }
                        });
                    }
                }

                return newBoxes;
            };

            const handleCanvasMouseDown = (e) => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;
                
                // Check if clicking on a box or handle
                for (let i = boxes.length - 1; i >= 0; i--) {
                    const box = boxes[i];
                    const handleSize = 12;
                    
                    // Check resize handles first
                    if (Math.abs(mouseX - box.x) < handleSize && Math.abs(mouseY - box.y) < handleSize) {
                        setDragging({ index: i, type: 'resize-tl' });
                        return;
                    }
                    if (Math.abs(mouseX - (box.x + box.width)) < handleSize && Math.abs(mouseY - box.y) < handleSize) {
                        setDragging({ index: i, type: 'resize-tr' });
                        return;
                    }
                    if (Math.abs(mouseX - box.x) < handleSize && Math.abs(mouseY - (box.y + box.height)) < handleSize) {
                        setDragging({ index: i, type: 'resize-bl' });
                        return;
                    }
                    if (Math.abs(mouseX - (box.x + box.width)) < handleSize && Math.abs(mouseY - (box.y + box.height)) < handleSize) {
                        setDragging({ index: i, type: 'resize-br' });
                        return;
                    }
                    
                    // Check if inside box for dragging
                    if (mouseX >= box.x && mouseX <= box.x + box.width &&
                        mouseY >= box.y && mouseY <= box.y + box.height) {
                        setDragging({ 
                            index: i, 
                            type: 'move',
                            startX: mouseX - box.x,
                            startY: mouseY - box.y
                        });
                        return;
                    }
                }
            };

            const handleCanvasMouseMove = (e) => {
                if (!dragging) return;
                
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;
                
                let newBoxes = [...boxes];
                const box = newBoxes[dragging.index];
                
                if (dragging.type === 'move') {
                    box.x = Math.max(0, Math.min(canvas.width - box.width, mouseX - dragging.startX));
                    box.y = Math.max(0, Math.min(canvas.height - box.height, mouseY - dragging.startY));
                } else if (dragging.type.startsWith('resize-')) {
                    const minWidth = 50;
                    let newWidth = box.width;

                    if (cutMode === 1 || cutMode === 2) {
                        let aspectRatio;
                        if (cutMode === 1) {
                            aspectRatio = 1080 / 1920; // 1080:1920 ratio for full vertical reel
                        } else {
                            aspectRatio = 1080 / 960; // 1080:960 ratio for half reels
                        }

                        if (dragging.type === 'resize-tl') {
                            newWidth = box.x + box.width - mouseX;
                            if (newWidth > minWidth) {
                                const newHeight = newWidth / aspectRatio;
                                box.x = box.x + box.width - newWidth;
                                box.y = box.y + box.height - newHeight;
                                newBoxes = syncBoxSize(dragging.index, newWidth);
                            }
                        } else if (dragging.type === 'resize-tr') {
                            newWidth = mouseX - box.x;
                            if (newWidth > minWidth) {
                                const newHeight = newWidth / aspectRatio;
                                box.y = box.y + box.height - newHeight;
                                newBoxes = syncBoxSize(dragging.index, newWidth);
                            }
                        } else if (dragging.type === 'resize-bl') {
                            newWidth = box.x + box.width - mouseX;
                            if (newWidth > minWidth) {
                                const newHeight = newWidth / aspectRatio;
                                box.x = box.x + box.width - newWidth;
                                newBoxes = syncBoxSize(dragging.index, newWidth);
                            }
                        } else if (dragging.type === 'resize-br') {
                            newWidth = mouseX - box.x;
                            if (newWidth > minWidth) {
                                newBoxes = syncBoxSize(dragging.index, newWidth);
                            }
                        }
                    } else if (cutMode === 3) {
                        // Special handling for 3-cut mode
                        if (box.type === 'square') {
                            // For squares, maintain 1:1 aspect ratio
                            if (dragging.type === 'resize-tl') {
                                newWidth = box.x + box.width - mouseX;
                                if (newWidth > minWidth) {
                                    box.x = box.x + box.width - newWidth;
                                    box.y = box.y + box.height - newWidth; // Keep square
                                    newBoxes = syncBoxSize(dragging.index, newWidth);
                                }
                            } else if (dragging.type === 'resize-tr') {
                                newWidth = mouseX - box.x;
                                if (newWidth > minWidth) {
                                    box.y = box.y + box.height - newWidth; // Keep square
                                    newBoxes = syncBoxSize(dragging.index, newWidth);
                                }
                            } else if (dragging.type === 'resize-bl') {
                                newWidth = box.x + box.width - mouseX;
                                if (newWidth > minWidth) {
                                    box.x = box.x + box.width - newWidth;
                                    newBoxes = syncBoxSize(dragging.index, newWidth);
                                }
                            } else if (dragging.type === 'resize-br') {
                                newWidth = mouseX - box.x;
                                if (newWidth > minWidth) {
                                    newBoxes = syncBoxSize(dragging.index, newWidth);
                                }
                            }
                        } else if (box.type === 'rectangle') {
                            // For rectangle, it resizes vertically and maintains proportional width to squares
                            if (dragging.type === 'resize-tl') {
                                const newHeight = box.y + box.height - mouseY;
                                if (newHeight > 50) {
                                    box.y = box.y + box.height - newHeight;
                                    box.height = newHeight;
                                    newBoxes = syncBoxSize(dragging.index, box.width);
                                }
                            } else if (dragging.type === 'resize-tr') {
                                const newHeight = box.y + box.height - mouseY;
                                if (newHeight > 50) {
                                    box.y = box.y + box.height - newHeight;
                                    box.height = newHeight;
                                    newBoxes = syncBoxSize(dragging.index, box.width);
                                }
                            } else if (dragging.type === 'resize-bl') {
                                const newHeight = mouseY - box.y;
                                if (newHeight > 50) {
                                    box.height = newHeight;
                                    newBoxes = syncBoxSize(dragging.index, box.width);
                                }
                            } else if (dragging.type === 'resize-br') {
                                const newHeight = mouseY - box.y;
                                if (newHeight > 50) {
                                    box.height = newHeight;
                                    newBoxes = syncBoxSize(dragging.index, box.width);
                                }
                            }
                        }
                    }
                }
                
                setBoxes(newBoxes);
            };

            const handleCanvasMouseUp = () => {
                setDragging(null);
            };

            // Subtitle dragging functions
            const handleSubtitleMouseDown = (e) => {
                e.preventDefault();
                setSubtitleDragging(true);
            };

            const handleSubtitleMouseMove = (e) => {
                if (!subtitleDragging) return;

                const previewBox = e.currentTarget.closest('.subtitle-preview');
                const rect = previewBox.getBoundingClientRect();
                const relativeY = e.clientY - rect.top;
                const percentage = Math.max(0, Math.min(100, (relativeY / rect.height) * 100));

                // Convert to pixels from bottom for ASS subtitles (1080px height)
                // Bottom of screen = 50px, Top of screen = 1050px
                const pixelsFromBottom = Math.round((1 - percentage / 100) * 1000) + 50;
                setSubtitlePosition(pixelsFromBottom);
            };

            const handleSubtitleMouseUp = () => {
                setSubtitleDragging(false);
            };

            // Global mouse events for subtitle dragging
            useEffect(() => {
                if (subtitleDragging) {
                    const handleGlobalMouseMove = (e) => {
                        const previewBoxes = document.querySelectorAll('.subtitle-preview');
                        if (previewBoxes.length > 0) {
                            const previewBox = previewBoxes[0];
                            const rect = previewBox.getBoundingClientRect();
                            const relativeY = e.clientY - rect.top;
                            const percentage = Math.max(0, Math.min(100, (relativeY / rect.height) * 100));

                            // Convert to pixels from bottom for ASS subtitles (1080px height)
                            // Bottom of screen = 50px, Top of screen = 1050px
                            const pixelsFromBottom = Math.round((1 - percentage / 100) * 1000) + 50;
                            setSubtitlePosition(pixelsFromBottom);
                        }
                    };

                    const handleGlobalMouseUp = () => {
                        setSubtitleDragging(false);
                    };

                    document.addEventListener('mousemove', handleGlobalMouseMove);
                    document.addEventListener('mouseup', handleGlobalMouseUp);

                    return () => {
                        document.removeEventListener('mousemove', handleGlobalMouseMove);
                        document.removeEventListener('mouseup', handleGlobalMouseUp);
                    };
                }
            }, [subtitleDragging]);

            return (
                <div className="container">
                    <div className="main-content">
                        <div className="header">
                            <div className="logo">‚ö° VIBE REEL</div>
                            <h1>Video Cut Rectangle Tool</h1>
                            <div className="subtitle">Manual rectangle positioning ‚Üí 1 cut (1080√ó1920) | 2 cuts (1080√ó960 each) | 3 cuts (2 squares + rectangle)</div>
                        </div>

                    {!video && (
                        <>
                            <div className="controls">
                                <div className="control-group">
                                    <div className="control-label">Cut Mode</div>
                                    <div style={{display: 'flex', gap: '10px'}}>
                                        <button
                                            className={`detect-btn ${cutMode === 1 ? 'active' : ''}`}
                                            onClick={() => setCutMode(1)}
                                            style={{padding: '8px 20px', fontSize: '12px'}}
                                        >
                                            1 Cut (1080√ó1920)
                                        </button>
                                        <button
                                            className={`detect-btn ${cutMode === 2 ? 'active' : ''}`}
                                            onClick={() => setCutMode(2)}
                                            style={{padding: '8px 20px', fontSize: '12px'}}
                                        >
                                            2 Cuts (1080√ó960 each)
                                        </button>
                                        <button
                                            className={`detect-btn ${cutMode === 3 ? 'active' : ''}`}
                                            onClick={() => setCutMode(3)}
                                            style={{padding: '8px 20px', fontSize: '12px'}}
                                        >
                                            3 Cuts (2 squares + rectangle)
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <div className="info-box">
                                <strong>üéØ How it works:</strong><br/>
                                1. Choose cut mode (1 or 2 rectangles) ‚Üí Upload video<br/>
                                2. Add rectangles manually ‚Üí Drag to reposition | Drag corners to resize<br/>
                                3. <strong>{cutMode === 1 ? '1 rectangle (1080√ó1920)' : cutMode === 2 ? '2 rectangles (1080√ó960 each)' : '2 squares + 1 rectangle (total height: 1920)'}</strong><br/>
                                4. Copy FFmpeg commands ‚Üí Perfect for vertical reels
                            </div>
                            
                            <div
                                className={`upload-section ${dragOver ? 'drag-over' : ''}`}
                                onClick={() => fileInputRef.current.click()}
                                onDragOver={handleDragOver}
                                onDragLeave={handleDragLeave}
                                onDrop={handleDrop}
                            >
                                <div className="upload-icon">üé•</div>
                                <div className="upload-text">
                                    {dragOver ? 'Drop video file here' : 'Click to upload or drag & drop video file'}
                                </div>
                                <input ref={fileInputRef} type="file" accept="video/*" onChange={(e) => handleFileSelect(e.target.files[0])} />
                            </div>
                        </>
                    )}

                    {video && (
                        <>
                            <div className="controls">
                                <div className="control-group">
                                    <div className="control-label">Timestamp (seconds)</div>
                                    <input
                                        type="number"
                                        className="time-input"
                                        value={seekTime}
                                        onChange={(e) => setSeekTime(Number(e.target.value))}
                                        min="0"
                                    />
                                </div>
                                <button className="detect-btn" onClick={loadVideoFrame}>
                                    üé¨ Load Frame
                                </button>
                            </div>

                            <div className="controls">
                                <div className="control-group">
                                    <div className="control-label">Rectangle Controls</div>
                                    <div style={{display: 'flex', gap: '10px'}}>
                                        <button
                                            className="detect-btn"
                                            onClick={addRectangle}
                                            disabled={cutMode === 1 ? boxes.length >= 1 : cutMode === 2 ? boxes.length >= 2 : boxes.length >= 3}
                                            style={{padding: '8px 20px', fontSize: '12px'}}
                                        >
                                            ‚ûï Add Rectangle
                                        </button>
                                        <button
                                            className="detect-btn"
                                            onClick={removeRectangle}
                                            disabled={boxes.length === 0}
                                            style={{padding: '8px 20px', fontSize: '12px', background: 'var(--accent-red)'}}
                                        >
                                            ‚ûñ Remove Last
                                        </button>
                                        <button
                                            className="detect-btn"
                                            onClick={clearAllRectangles}
                                            disabled={boxes.length === 0}
                                            style={{padding: '8px 20px', fontSize: '12px', background: 'var(--accent-red)'}}
                                        >
                                            üóëÔ∏è Clear All
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <video ref={videoRef} src={videoUrl} style={{display: 'none'}} />
                            
                            <div className="canvas-wrapper">
                                <canvas 
                                    ref={canvasRef} 
                                    className="video-canvas"
                                    onMouseDown={handleCanvasMouseDown}
                                    onMouseMove={handleCanvasMouseMove}
                                    onMouseUp={handleCanvasMouseUp}
                                    onMouseLeave={handleCanvasMouseUp}
                                />
                            </div>
                            
                            {boxes.length > 0 && (
                                <div className="help-text">
                                    ‚ú® Drag to move | Drag corners to resize
                                    {cutMode === 1 && <span className="sync-badge">1080√ó1920</span>}
                                    {cutMode === 2 && <span className="sync-badge">1080√ó960</span>}
                                    {cutMode === 3 && <span className="sync-badge">Squares: 1:1 | Rectangle: Auto-calculated</span>}
                                    {cutMode === 2 && boxes.length > 1 && <span className="sync-badge">Both boxes resize together</span>}
                                    {cutMode === 3 && boxes.length > 1 && <span className="sync-badge">All shapes sync | Total height: 1920px</span>}
                                </div>
                            )}

                            {boxes.length > 0 && (
                                <div className="results-grid">
                                    {boxes.map(box => (
                                        <div key={box.id} className="participant-card">
                                            <div className="participant-id">
                                                {cutMode === 3 ? (box.type === 'square' ? `Square ${box.id}` : 'Rectangle') : `Cut ${box.id}`}
                                                {cutMode === 2 && boxes.length > 1 && <span className="sync-badge">SYNCED SIZE</span>}
                                                {cutMode === 1 && <span className="sync-badge">FULL REEL</span>}
                                                {cutMode === 3 && box.type === 'square' && <span className="sync-badge">1:1 RATIO</span>}
                                                {cutMode === 3 && box.type === 'rectangle' && <span className="sync-badge">AUTO-HEIGHT</span>}
                                            </div>
                                            <div className="coord-value">Position: ({box.x}, {box.y})</div>
                                            <div className="coord-value">Size: {box.width} √ó {box.height}</div>
                                            <div className="coord-value">crop={box.width}:{box.height}:{box.x}:{box.y}</div>
                                            <div className="ffmpeg-command">
                                                <div className="ffmpeg-code">zsh -lc 'source ~/.zshrc; rm -rf cut{box.id}.mp4; ffmpeg -i video.mp4 -vf "crop={box.width}:{box.height}:{box.x}:{box.y}" -c:v libx264 -crf 18 -preset medium -c:a copy cut{box.id}.mp4'</div>
                                                <button
                                                    className="copy-btn"
                                                    onClick={() => navigator.clipboard.writeText(
                                                        `zsh -lc 'source ~/.zshrc; rm -rf cut${box.id}.mp4; ffmpeg -i video.mp4 -vf "crop=${box.width}:${box.height}:${box.x}:${box.y}" -c:v libx264 -crf 18 -preset medium -c:a copy cut${box.id}.mp4'`
                                                    )}
                                                >
                                                    Copy
                                                </button>
                                            </div>
                                        </div>
                                    ))}
                                    
                                    {boxes.length === 2 && cutMode === 2 && (
                                        <div className="participant-card" style={{gridColumn: '1 / -1', background: 'var(--bg-input)', borderColor: 'var(--accent-green)'}}>
                                            <div className="participant-id" style={{color: 'var(--accent-green)'}}>
                                                üìö Merge Both Cuts
                                            </div>
                                            <div className="ffmpeg-command">
                                                <div className="ffmpeg-code">zsh -lc 'source ~/.zshrc; rm -rf merged.mp4; ffmpeg -i cut1.mp4 -i cut2.mp4 -filter_complex "[0:v][1:v]vstack=inputs=2[v]" -map "[v]" -map "0:a?" merged.mp4'</div>
                                                <button 
                                                    className="copy-btn" 
                                                    onClick={() => navigator.clipboard.writeText(
                                                        `zsh -lc 'source ~/.zshrc; rm -rf merged.mp4; ffmpeg -i cut1.mp4 -i cut2.mp4 -filter_complex "[0:v][1:v]vstack=inputs=2[v]" -map "[v]" -map "0:a?" merged.mp4'`
                                                    )}
                                                >
                                                    Copy
                                                </button>
                                            </div>
                                        </div>
                                    )}

                                    {boxes.length === 3 && cutMode === 3 && (
                                        <div className="participant-card" style={{gridColumn: '1 / -1', background: 'var(--bg-input)', borderColor: 'var(--accent-green)'}}>
                                            <div className="participant-id" style={{color: 'var(--accent-green)'}}>
                                                üé¨ Merge All Three Cuts
                                            </div>
                                            <div className="ffmpeg-command">
                                                <div className="ffmpeg-code">zsh -lc 'source ~/.zshrc; rm -rf merged_3cut.mp4; ffmpeg -i cut1.mp4 -i cut2.mp4 -i cut3.mp4 -filter_complex \"[0:v][1:v]hstack=inputs=2[squares];[squares][2:v]vstack=inputs=2[v]\" -map \"[v]\" -map \"0:a?\" merged_3cut.mp4'</div>
                                                <button
                                                    className="copy-btn"
                                                    onClick={() => navigator.clipboard.writeText(
                                                        `zsh -lc 'source ~/.zshrc; rm -rf merged_3cut.mp4; ffmpeg -i cut1.mp4 -i cut2.mp4 -i cut3.mp4 -filter_complex \"[0:v][1:v]hstack=inputs=2[squares];[squares][2:v]vstack=inputs=2[v]\" -map \"[v]\" -map \"0:a?\" merged_3cut.mp4'`
                                                    )}
                                                >
                                                    Copy
                                                </button>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            )}
                        </>
                    )}
                    </div>

                    <div className="right-sidebar">
                        <div className="sidebar-section">
                            <div className="sidebar-title">Subtitle Position</div>
                            <div className="subtitle-preview">
                                <div className="subtitle-preview-label">Pixels from Bottom</div>
                                <div
                                    className={`subtitle-placeholder ${subtitleDragging ? 'dragging' : ''}`}
                                    style={{ top: `calc(${(1 - (subtitlePosition - 50) / 1000) * 100}% - 20px)` }}
                                    onMouseDown={handleSubtitleMouseDown}
                                >
                                    {subtitlePosition}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
