<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Cut Rectangle Tool - Vibe Reel</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --bg-dark: #0a0e14;
            --bg-card: #151921;
            --bg-input: #1a1f2b;
            --accent-cyan: #00d9ff;
            --accent-green: #00ff9f;
            --accent-yellow: #ffd500;
            --accent-red: #ff3366;
            --text-primary: #e6e9ef;
            --text-secondary: #8b92a3;
            --border: #2a2f3a;
        }
        
        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
        }
        
        .container { max-width: 1400px; margin: 0 auto; padding: 40px 20px; }
        .header { text-align: center; margin-bottom: 50px; }
        .logo { font-size: 14px; letter-spacing: 3px; color: var(--accent-cyan); margin-bottom: 10px; font-weight: 700; text-transform: uppercase; }
        h1 { font-size: 48px; font-weight: 700; margin-bottom: 15px; background: linear-gradient(135deg, var(--accent-cyan), var(--accent-green)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .subtitle { color: var(--text-secondary); font-size: 14px; }
        
        .upload-section {
            background: var(--bg-card);
            border: 2px dashed var(--border);
            border-radius: 12px;
            padding: 60px 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .upload-section:hover { border-color: var(--accent-cyan); }
        .upload-section.drag-over {
            border-color: var(--accent-green);
            background: rgba(0, 255, 159, 0.1);
            transform: scale(1.02);
        }
        .upload-icon { font-size: 64px; margin-bottom: 20px; }
        .upload-text { font-size: 16px; margin-bottom: 10px; font-weight: 600; }
        
        .controls { display: flex; gap: 15px; margin: 30px 0; align-items: center; flex-wrap: wrap; }
        .control-group { flex: 1; min-width: 200px; }
        .control-label { font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase; }
        .time-input { width: 100%; padding: 12px 15px; background: var(--bg-input); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-family: 'JetBrains Mono', monospace; font-size: 14px; }
        
        .detect-btn { padding: 14px 40px; background: linear-gradient(135deg, var(--accent-cyan), var(--accent-green)); border: none; border-radius: 8px; color: var(--bg-dark); font-family: 'JetBrains Mono', monospace; font-size: 14px; font-weight: 700; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease; }
        .detect-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .detect-btn.active { background: var(--accent-yellow); color: var(--bg-dark); transform: scale(1.05); }
        .detect-btn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0, 217, 255, 0.3); }
        
        .canvas-wrapper {
            position: relative;
            margin: 20px 0;
            border-radius: 8px;
            overflow: hidden;
            background: var(--bg-card);
        }
        
        .video-canvas { 
            width: 100%; 
            display: block;
            cursor: crosshair;
        }
        
        .help-text {
            text-align: center;
            color: var(--accent-green);
            font-size: 13px;
            margin: 10px 0;
            padding: 10px;
            background: rgba(0, 255, 159, 0.1);
            border-radius: 8px;
        }
        
        .sync-badge {
            display: inline-block;
            padding: 4px 12px;
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid var(--accent-yellow);
            border-radius: 20px;
            font-size: 11px;
            color: var(--accent-yellow);
            margin-left: 10px;
        }
        
        .results-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-top: 30px; }
        .participant-card { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 20px; }
        .participant-id { font-size: 18px; font-weight: 700; color: var(--accent-cyan); margin-bottom: 15px; }
        .coord-value { font-size: 14px; color: var(--accent-green); margin: 8px 0; }
        
        .ffmpeg-command { background: var(--bg-input); border-radius: 8px; padding: 15px; margin-top: 15px; position: relative; }
        .ffmpeg-code { font-size: 11px; color: var(--accent-yellow); word-break: break-all; padding-right: 60px; line-height: 1.6; }
        .copy-btn { position: absolute; top: 15px; right: 15px; padding: 6px 12px; background: var(--accent-cyan); color: var(--bg-dark); border: none; border-radius: 4px; cursor: pointer; font-size: 11px; }
        
        .loading { text-align: center; padding: 40px; color: var(--text-secondary); }
        .spinner { width: 40px; height: 40px; margin: 0 auto 20px; border: 3px solid var(--border); border-top-color: var(--accent-cyan); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        input[type="file"] { display: none; }
        
        .info-box {
            background: rgba(0, 217, 255, 0.1);
            border: 1px solid rgba(0, 217, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;
        const COLORS = ['#00d9ff', '#00ff9f'];

        function App() {
            const [video, setVideo] = useState(null);
            const [videoUrl, setVideoUrl] = useState(null);
            const [boxes, setBoxes] = useState([]);
            const [cutMode, setCutMode] = useState(2); // 1 or 2 cuts
            const [seekTime, setSeekTime] = useState(10);
            const [dragging, setDragging] = useState(null);
            const [videoFrame, setVideoFrame] = useState(null);
            const [dragOver, setDragOver] = useState(false);
            
            const fileInputRef = useRef(null);
            const videoRef = useRef(null);
            const canvasRef = useRef(null);

            useEffect(() => {
                // Prevent default browser drag and drop behavior
                const handleGlobalDragOver = (e) => e.preventDefault();
                const handleGlobalDrop = (e) => e.preventDefault();

                document.addEventListener('dragover', handleGlobalDragOver);
                document.addEventListener('drop', handleGlobalDrop);

                return () => {
                    document.removeEventListener('dragover', handleGlobalDragOver);
                    document.removeEventListener('drop', handleGlobalDrop);
                };
            }, []);

            useEffect(() => {
                if (boxes.length > 0 && videoFrame) {
                    redrawCanvas();
                }
            }, [boxes, videoFrame]);

            useEffect(() => {
                // Reset boxes when cut mode changes
                setBoxes([]);
            }, [cutMode]);


            const handleFileSelect = (file) => {
                if (file && file.type.startsWith('video/')) {
                    setVideo(file);
                    setVideoUrl(URL.createObjectURL(file));
                    setBoxes([]);
                    // Load the first frame
                    setTimeout(() => loadVideoFrame(), 500);
                }
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setDragOver(true);
            };

            const handleDragLeave = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setDragOver(false);
            };

            const handleDrop = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setDragOver(false);

                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (file.type.startsWith('video/')) {
                        handleFileSelect(file);
                    } else {
                        alert('Please upload a video file');
                    }
                }
            };

            const loadVideoFrame = async () => {
                if (!videoRef.current || !canvasRef.current) return;

                const videoEl = videoRef.current;
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');

                await new Promise((resolve) => {
                    if (videoEl.readyState >= 1) resolve();
                    else videoEl.onloadedmetadata = resolve;
                });

                const width = videoEl.videoWidth;
                const height = videoEl.videoHeight;
                canvas.width = width;
                canvas.height = height;

                videoEl.currentTime = Math.min(seekTime, videoEl.duration - 1);
                await new Promise((resolve) => { videoEl.onseeked = resolve; });
                await new Promise(resolve => setTimeout(resolve, 200));

                ctx.drawImage(videoEl, 0, 0, width, height);

                // Store frame for redrawing
                setVideoFrame(ctx.getImageData(0, 0, width, height));
            };

            const addRectangle = () => {
                if (!canvasRef.current) return;

                const canvas = canvasRef.current;
                const width = canvas.width;
                const height = canvas.height;

                let newBox;

                if (cutMode === 1) {
                    // Single cut - full vertical reel (1080x1920)
                    if (boxes.length >= 1) return; // Only allow one rectangle

                    const aspectRatio = 1080 / 1920;
                    let boxWidth, boxHeight;

                    // Fit 1080x1920 ratio within canvas
                    const maxWidthFromHeight = height * aspectRatio;
                    const maxHeightFromWidth = width / aspectRatio;

                    if (maxWidthFromHeight <= width) {
                        boxHeight = height * 0.8; // 80% of canvas height
                        boxWidth = boxHeight * aspectRatio;
                    } else {
                        boxWidth = width * 0.8; // 80% of canvas width
                        boxHeight = boxWidth / aspectRatio;
                    }

                    newBox = {
                        id: 1,
                        x: (width - boxWidth) / 2,
                        y: (height - boxHeight) / 2,
                        width: Math.floor(boxWidth),
                        height: Math.floor(boxHeight),
                        color: COLORS[0]
                    };
                } else {
                    // Two cuts - half reels (1080x960 each)
                    if (boxes.length >= 2) return; // Only allow two rectangles

                    const aspectRatio = 1080 / 960;
                    let boxWidth, boxHeight;

                    // Fit 1080x960 ratio within canvas
                    const maxWidthFromHeight = (height / 2) * aspectRatio;
                    const maxHeightFromWidth = width / aspectRatio;

                    if (maxWidthFromHeight <= width) {
                        boxHeight = (height / 2) * 0.8; // 80% of half canvas height
                        boxWidth = boxHeight * aspectRatio;
                    } else {
                        boxWidth = width * 0.8; // 80% of canvas width
                        boxHeight = boxWidth / aspectRatio;
                    }

                    const yOffset = boxes.length === 0 ? height * 0.1 : height * 0.6;

                    newBox = {
                        id: boxes.length + 1,
                        x: (width - boxWidth) / 2,
                        y: yOffset,
                        width: Math.floor(boxWidth),
                        height: Math.floor(boxHeight),
                        color: COLORS[boxes.length % COLORS.length]
                    };
                }

                setBoxes([...boxes, newBox]);
            };

            const removeRectangle = () => {
                if (boxes.length > 0) {
                    setBoxes(boxes.slice(0, -1));
                }
            };

            const clearAllRectangles = () => {
                setBoxes([]);
            };

            const redrawCanvas = () => {
                const canvas = canvasRef.current;
                if (!canvas || !videoFrame) return;
                
                const ctx = canvas.getContext('2d');
                
                // Redraw original frame
                ctx.putImageData(videoFrame, 0, 0);
                
                // Draw boxes
                boxes.forEach(box => {
                    // Box
                    ctx.strokeStyle = box.color;
                    ctx.lineWidth = 4;
                    ctx.strokeRect(box.x, box.y, box.width, box.height);
                    
                    // Label
                    ctx.fillStyle = box.color;
                    ctx.font = 'bold 24px JetBrains Mono';
                    ctx.fillText(`Cut ${box.id}`, box.x + 10, box.y + 35);
                    
                    // Size indicator
                    ctx.font = '16px JetBrains Mono';
                    ctx.fillText(`${box.width}√ó${box.height}`, box.x + 10, box.y + box.height - 10);
                    
                    // Resize handles (corners)
                    const handleSize = 12;
                    ctx.fillStyle = box.color;
                    
                    // Top-left
                    ctx.fillRect(box.x - handleSize/2, box.y - handleSize/2, handleSize, handleSize);
                    // Top-right
                    ctx.fillRect(box.x + box.width - handleSize/2, box.y - handleSize/2, handleSize, handleSize);
                    // Bottom-left
                    ctx.fillRect(box.x - handleSize/2, box.y + box.height - handleSize/2, handleSize, handleSize);
                    // Bottom-right
                    ctx.fillRect(box.x + box.width - handleSize/2, box.y + box.height - handleSize/2, handleSize, handleSize);
                });
            };

            const syncBoxSize = (changedIndex, newWidth) => {
                const newBoxes = [...boxes];
                let aspectRatio;

                if (cutMode === 1) {
                    aspectRatio = 1080 / 1920; // 1080:1920 ratio for full vertical reel
                } else {
                    aspectRatio = 1080 / 960; // 1080:960 ratio for half reels
                }

                const newHeight = newWidth / aspectRatio;

                // Update all boxes to same size
                newBoxes.forEach((box, index) => {
                    box.width = newWidth;
                    box.height = newHeight;
                });

                return newBoxes;
            };

            const handleCanvasMouseDown = (e) => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;
                
                // Check if clicking on a box or handle
                for (let i = boxes.length - 1; i >= 0; i--) {
                    const box = boxes[i];
                    const handleSize = 12;
                    
                    // Check resize handles first
                    if (Math.abs(mouseX - box.x) < handleSize && Math.abs(mouseY - box.y) < handleSize) {
                        setDragging({ index: i, type: 'resize-tl' });
                        return;
                    }
                    if (Math.abs(mouseX - (box.x + box.width)) < handleSize && Math.abs(mouseY - box.y) < handleSize) {
                        setDragging({ index: i, type: 'resize-tr' });
                        return;
                    }
                    if (Math.abs(mouseX - box.x) < handleSize && Math.abs(mouseY - (box.y + box.height)) < handleSize) {
                        setDragging({ index: i, type: 'resize-bl' });
                        return;
                    }
                    if (Math.abs(mouseX - (box.x + box.width)) < handleSize && Math.abs(mouseY - (box.y + box.height)) < handleSize) {
                        setDragging({ index: i, type: 'resize-br' });
                        return;
                    }
                    
                    // Check if inside box for dragging
                    if (mouseX >= box.x && mouseX <= box.x + box.width &&
                        mouseY >= box.y && mouseY <= box.y + box.height) {
                        setDragging({ 
                            index: i, 
                            type: 'move',
                            startX: mouseX - box.x,
                            startY: mouseY - box.y
                        });
                        return;
                    }
                }
            };

            const handleCanvasMouseMove = (e) => {
                if (!dragging) return;
                
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;
                
                let newBoxes = [...boxes];
                const box = newBoxes[dragging.index];
                
                if (dragging.type === 'move') {
                    box.x = Math.max(0, Math.min(canvas.width - box.width, mouseX - dragging.startX));
                    box.y = Math.max(0, Math.min(canvas.height - box.height, mouseY - dragging.startY));
                } else if (dragging.type.startsWith('resize-')) {
                    const minWidth = 50;
                    let aspectRatio;

                    if (cutMode === 1) {
                        aspectRatio = 1080 / 1920; // 1080:1920 ratio for full vertical reel
                    } else {
                        aspectRatio = 1080 / 960; // 1080:960 ratio for half reels
                    }

                    let newWidth = box.width;

                    if (dragging.type === 'resize-tl') {
                        newWidth = box.x + box.width - mouseX;
                        if (newWidth > minWidth) {
                            const newHeight = newWidth / aspectRatio;
                            box.x = box.x + box.width - newWidth;
                            box.y = box.y + box.height - newHeight;
                            newBoxes = syncBoxSize(dragging.index, newWidth);
                        }
                    } else if (dragging.type === 'resize-tr') {
                        newWidth = mouseX - box.x;
                        if (newWidth > minWidth) {
                            const newHeight = newWidth / aspectRatio;
                            box.y = box.y + box.height - newHeight;
                            newBoxes = syncBoxSize(dragging.index, newWidth);
                        }
                    } else if (dragging.type === 'resize-bl') {
                        newWidth = box.x + box.width - mouseX;
                        if (newWidth > minWidth) {
                            const newHeight = newWidth / aspectRatio;
                            box.x = box.x + box.width - newWidth;
                            newBoxes = syncBoxSize(dragging.index, newWidth);
                        }
                    } else if (dragging.type === 'resize-br') {
                        newWidth = mouseX - box.x;
                        if (newWidth > minWidth) {
                            newBoxes = syncBoxSize(dragging.index, newWidth);
                        }
                    }
                }
                
                setBoxes(newBoxes);
            };

            const handleCanvasMouseUp = () => {
                setDragging(null);
            };

            return (
                <div className="container">
                    <div className="header">
                        <div className="logo">‚ö° VIBE REEL</div>
                        <h1>Video Cut Rectangle Tool</h1>
                        <div className="subtitle">Manual rectangle positioning ‚Üí 1 cut (1080√ó1920) or 2 cuts (1080√ó960 each)</div>
                    </div>

                    {!video && (
                        <>
                            <div className="controls">
                                <div className="control-group">
                                    <div className="control-label">Cut Mode</div>
                                    <div style={{display: 'flex', gap: '10px'}}>
                                        <button
                                            className={`detect-btn ${cutMode === 1 ? 'active' : ''}`}
                                            onClick={() => setCutMode(1)}
                                            style={{padding: '8px 20px', fontSize: '12px'}}
                                        >
                                            1 Cut (1080√ó1920)
                                        </button>
                                        <button
                                            className={`detect-btn ${cutMode === 2 ? 'active' : ''}`}
                                            onClick={() => setCutMode(2)}
                                            style={{padding: '8px 20px', fontSize: '12px'}}
                                        >
                                            2 Cuts (1080√ó960 each)
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <div className="info-box">
                                <strong>üéØ How it works:</strong><br/>
                                1. Choose cut mode (1 or 2 rectangles) ‚Üí Upload video<br/>
                                2. Add rectangles manually ‚Üí Drag to reposition | Drag corners to resize<br/>
                                3. <strong>{cutMode === 1 ? '1 rectangle (1080√ó1920)' : '2 rectangles (1080√ó960 each)'}</strong><br/>
                                4. Copy FFmpeg commands ‚Üí Perfect for vertical reels
                            </div>
                            
                            <div
                                className={`upload-section ${dragOver ? 'drag-over' : ''}`}
                                onClick={() => fileInputRef.current.click()}
                                onDragOver={handleDragOver}
                                onDragLeave={handleDragLeave}
                                onDrop={handleDrop}
                            >
                                <div className="upload-icon">üé•</div>
                                <div className="upload-text">
                                    {dragOver ? 'Drop video file here' : 'Click to upload or drag & drop video file'}
                                </div>
                                <input ref={fileInputRef} type="file" accept="video/*" onChange={(e) => handleFileSelect(e.target.files[0])} />
                            </div>
                        </>
                    )}

                    {video && (
                        <>
                            <div className="controls">
                                <div className="control-group">
                                    <div className="control-label">Timestamp (seconds)</div>
                                    <input
                                        type="number"
                                        className="time-input"
                                        value={seekTime}
                                        onChange={(e) => setSeekTime(Number(e.target.value))}
                                        min="0"
                                    />
                                </div>
                                <button className="detect-btn" onClick={loadVideoFrame}>
                                    üé¨ Load Frame
                                </button>
                            </div>

                            <div className="controls">
                                <div className="control-group">
                                    <div className="control-label">Rectangle Controls</div>
                                    <div style={{display: 'flex', gap: '10px'}}>
                                        <button
                                            className="detect-btn"
                                            onClick={addRectangle}
                                            disabled={cutMode === 1 ? boxes.length >= 1 : boxes.length >= 2}
                                            style={{padding: '8px 20px', fontSize: '12px'}}
                                        >
                                            ‚ûï Add Rectangle
                                        </button>
                                        <button
                                            className="detect-btn"
                                            onClick={removeRectangle}
                                            disabled={boxes.length === 0}
                                            style={{padding: '8px 20px', fontSize: '12px', background: 'var(--accent-red)'}}
                                        >
                                            ‚ûñ Remove Last
                                        </button>
                                        <button
                                            className="detect-btn"
                                            onClick={clearAllRectangles}
                                            disabled={boxes.length === 0}
                                            style={{padding: '8px 20px', fontSize: '12px', background: 'var(--accent-red)'}}
                                        >
                                            üóëÔ∏è Clear All
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <video ref={videoRef} src={videoUrl} style={{display: 'none'}} />
                            
                            <div className="canvas-wrapper">
                                <canvas 
                                    ref={canvasRef} 
                                    className="video-canvas"
                                    onMouseDown={handleCanvasMouseDown}
                                    onMouseMove={handleCanvasMouseMove}
                                    onMouseUp={handleCanvasMouseUp}
                                    onMouseLeave={handleCanvasMouseUp}
                                />
                            </div>
                            
                            {boxes.length > 0 && (
                                <div className="help-text">
                                    ‚ú® Drag to move | Drag corners to resize <span className="sync-badge">{cutMode === 1 ? '1080√ó1920' : '1080√ó960'}</span> {cutMode === 2 && boxes.length > 1 && <span className="sync-badge">Both boxes resize together</span>}
                                </div>
                            )}

                            {boxes.length > 0 && (
                                <div className="results-grid">
                                    {boxes.map(box => (
                                        <div key={box.id} className="participant-card">
                                            <div className="participant-id">
                                                Cut {box.id}
                                                {cutMode === 2 && boxes.length > 1 && <span className="sync-badge">SYNCED SIZE</span>}
                                                {cutMode === 1 && <span className="sync-badge">FULL REEL</span>}
                                            </div>
                                            <div className="coord-value">Position: ({box.x}, {box.y})</div>
                                            <div className="coord-value">Size: {box.width} √ó {box.height}</div>
                                            <div className="coord-value">crop={box.width}:{box.height}:{box.x}:{box.y}</div>
                                            <div className="ffmpeg-command">
                                                <div className="ffmpeg-code">zsh -lc 'source ~/.zshrc; rm -rf cut{box.id}.mp4; ffmpeg -i video.mp4 -vf "crop={box.width}:{box.height}:{box.x}:{box.y}" -c:v libx264 -crf 18 -preset medium -c:a copy cut{box.id}.mp4'</div>
                                                <button
                                                    className="copy-btn"
                                                    onClick={() => navigator.clipboard.writeText(
                                                        `zsh -lc 'source ~/.zshrc; rm -rf cut${box.id}.mp4; ffmpeg -i video.mp4 -vf "crop=${box.width}:${box.height}:${box.x}:${box.y}" -c:v libx264 -crf 18 -preset medium -c:a copy cut${box.id}.mp4'`
                                                    )}
                                                >
                                                    Copy
                                                </button>
                                            </div>
                                        </div>
                                    ))}
                                    
                                    {boxes.length === 2 && (
                                        <div className="participant-card" style={{gridColumn: '1 / -1', background: 'var(--bg-input)', borderColor: 'var(--accent-green)'}}>
                                            <div className="participant-id" style={{color: 'var(--accent-green)'}}>
                                                üìö Merge Both Cuts
                                            </div>
                                            <div className="ffmpeg-command">
                                                <div className="ffmpeg-code">zsh -lc 'source ~/.zshrc; rm -rf merged.mp4; ffmpeg -i cut1.mp4 -i cut2.mp4 -filter_complex "[0:v][1:v]vstack=inputs=2[v]" -map "[v]" -map "0:a?" merged.mp4'</div>
                                                <button 
                                                    className="copy-btn" 
                                                    onClick={() => navigator.clipboard.writeText(
                                                        `zsh -lc 'source ~/.zshrc; rm -rf merged.mp4; ffmpeg -i cut1.mp4 -i cut2.mp4 -filter_complex "[0:v][1:v]vstack=inputs=2[v]" -map "[v]" -map "0:a?" merged.mp4'`
                                                    )}
                                                >
                                                    Copy
                                                </button>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            )}
                        </>
                    )}
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
